#!/usr/bin/env perl

use 5.010001;
use strict;
use warnings;

use Moose;
with 'MooseX::Getopt';

use YAML::XS;
use TOML::Dumper;
use SQL::Parser;
use DBI;

has 'mml' => (
	is       => 'ro',
	isa      => 'Str',
	required => 1,
);

has 'port' => (
	is      => 'ro',
	isa     => 'Int',
	default => 8080,
);

has 'cache' => (
	traits   => ['Getopt'],
	cmd_flag => 'cache',
	is       => 'ro',
	isa      => 'Str',
	default  => 'file',
);

has 'cache_dir' => (
	traits   => ['Getopt'],
	cmd_flag => 'cache',
	is       => 'ro',
	isa      => 'Str',
	default  => '/tmp/tegola-cache',
);

has 'db_host' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-host',
	is       => 'ro',
	isa      => 'Str',
	default  => 'localhost',
);

has 'db_port' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-port',
	is       => 'ro',
	isa      => 'Str',
	default  => 5432,
);

has 'db_user' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-user',
	is       => 'ro',
	isa      => 'Str',
	required => 1,
);

has 'db_password' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-password',
	is       => 'ro',
	isa      => 'Str',
	required => 1,
);

has 'db_name' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-name',
	is       => 'ro',
	isa      => 'Str',
	required => 1,
);

has 'db_max_connections' => (
	traits   => ['Getopt'],
	cmd_flag => 'db-max-connections',
	is       => 'ro',
	isa      => 'Int',
	default  => 100,
);

has 'dbi_str' => (
	traits   => ['Getopt'],
	cmd_flag => 'dbi-str',
	is       => 'ro',
	isa      => 'Str',
);

has 'dbh' => (
	traits  => ['NoGetopt'],
	is      => 'ro',
	isa     => 'DBI::db',
	lazy    => 1,
	default => sub {
		my ($self) = @_;
		my @connect_param = $self->dbi_str()
			? ($self->dbi_str())
			: (
				'dbi:Pg:dbname=' . $self->db_name()
					. ';host=' . $self->db_host()
					. ';port=' . $self->db_port()
					. ';',
				$self->db_user(),
				$self->db_password()
			)
		;
		my $dbh = DBI->connect(@connect_param);
		$dbh->{pg_placeholder_dollaronly} = 1;  # ? is operator for hstore
		return $dbh;
	},
);


my %geometry_type_mapping = (
	linestring => 'LineString',
	point      => 'Point',
	polygon    => 'Polygon',
);

sub run {
	my ($self) = @_;

	my $mml_data = YAML::XS::LoadFile($self->mml());
	my @carto_layers = @{$mml_data->{Layer}};
	my @postgis_layers = grep {
		defined $_->{Datasource}->{'<<'}->{type}
			&& $_->{Datasource}->{'<<'}->{type} eq 'postgis'
	} @carto_layers;
	my @layers;
	my @map_layers;
	my $sql_parser = SQL::Parser->new();

	for my $layer (@postgis_layers) {
		my $sql = $layer->{Datasource}->{table};
		$sql =~ s{\\d}{\\\\d}g;
		$sql =~ s{\\(\d+)}{\\\\$1}g;
		$sql =~ s{\\\.}{\\\\.}g;
		my @columns = map {
			'"' . $_ . '"'
		} grep {
			$_ ne 'way'
		} $self->get_columns($sql);
		unshift @columns, 'ST_AsBinary(way) AS geom';
		my $columns = join(', ',  @columns);

		push @layers, {
			name               => $layer->{id},
			geometry_fieldname => 'geom',
			defined $layer->{geometry}
				? (geometry_type => $geometry_type_mapping{$layer->{geometry}})
				: (),
			sql                => 'SELECT ' . $columns . ' FROM ' . $sql . ' WHERE way && !BBOX!',
		};
		push @map_layers, {
			provider_layer => 'osm.' . $layer->{id},
			$layer->{properties}->{minzoom}
				? (min_zoom => $layer->{properties}->{minzoom})
				: (),
			$layer->{properties}->{maxzoom}
				? (max_zoom => $layer->{properties}->{maxzoom})
				: (),
		};
	}

	my $config = {
		webserver => {
			port => ':' . $self->port(),
		},
		providers => [{
			name            => 'osm',
			type            => 'postgis',
			host            => $self->db_host(),
			port            => $self->db_port(),
			database        => $self->db_name(),
			user            => $self->db_user(),
			password        => $self->db_password(),
			max_connections => $self->db_max_connections(),
			srid            => 3857,
			layers          => \@layers,
		}],
		maps => [{
			name   => 'osm',
			layers => \@map_layers,
		}],
	};

	if ($self->cache() ne 'none') {
		$config->{cache} = {
			type     => $self->cache(),
			basepath => $self->cache_dir(),
		}
	}

	my $config_str = TOML::Dumper->new->dump($config);
	$config_str =~ s{\\/}{/}g;
	say $config_str;
}


sub get_columns {
	my ($self, $sql) = @_;

	$sql =~ s{!scale_denominator!}{1}g;
	$sql =~ s{!bbox!}{ST_MakeEnvelope(-180.0, -85.06,  180.0, 85.06 ,4326)}gi;
	$sql =~ s{!pixel_(?:width|height)!}{42}g;
	$sql = 'SELECT * FROM ' . $sql . ' LIMIT 1';
	my $sth = $self->dbh()->prepare($sql);
	my $rv = $sth->execute();
	unless ($rv) {
		die("Failed to execute $sql");
	}

	return @{$sth->{NAME}};
}


__PACKAGE__->new_with_options()->run() unless caller();
